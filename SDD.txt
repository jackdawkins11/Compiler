
Dawkins Compiler

Scanner Chapter

The scanner is the first module of any compiler.
It takes as input a file containing code and then
implements a nextToken() function that, starting
from the first token in the file, outputs the next
token in the file. This was implemented using
the useful JFlex scanner generator for java along
with defining a token class and and an EnumToken
type. After writing this code, tests were created
for it. Because of the importance of testing, this
was carefully planned out. The test takes as
input two files. The first is pascal code,
the second is a list of all the tokens
from the code in the same order along with
their EnumToken types. 

SymbolTable

The SymbolTable is very straightforward,
it needs to be able to take in symbol
and save it. Then it needs to provide
access to it. Symbols were defined
in a Symbol class which had multiple
constructors and initializers for
each different kind of symbol.
Specifically Array, variable,
function or program, along with
the variable and arrays type and
size. Once a symbol was created it 
is added to the symbol table with
a simple add() method that takes as
input a symbol and stores it in the
symboltable stack. Then it is 
easy to implement functions that
search for Symbols and delete symbols.

Parser

The Recognizer is likely the most
mathematically complex element of
the Compiler. It has the task of creating a parser tree,
whether or not is saved in memory. This means using
recursive descent and backtracking to try
and follow possible paths down the grammar from
non-terminals. One other notable aspect of it
is the shear amount of code that must be written
to accomate functions for every different non-terminal
in the grammar. This was done, and the recognizer takes
as input a filename containing code, creates all the
tokens using the scanner and then begins executing the
non-terminal functions. It parses the tokens by calling
a non-terminal function, which returns a boolean true or
false if it is able to parse the input. It answers this
by again calling another non-terminal function
or eventually checkning actual tokens. After this was created,
a symbol table was added. The symbol table adds identifiers
to the table as they are declared and checks for the 
existence of them when they are used in statements and
expressions. The test for the recognizer consists of feeding
it programs that both work and don't work and making sure
it labels them accordingly. An important aspect of the tests
is using very similar programs for the good and bad files
to test specific features of the recognizer.

